local MAP_WIDTH = 48
local MAP_HEIGHT = 48

-- grid types: see tartarus_Defs

local map = {}
local rooms = {}
-- we store rooms because rooms need paths that can be connected to them,
-- so we need to know where we can put these paths.

local paths = {}
-- used for item and enemy generation

local function MAP_coord2table(x, y)
	return y*MAP_WIDTH+x
end

local function MAP_table2coord(i)
	local x = i % MAP_WIDTH
	local y = (i-x) / MAP_WIDTH
	return x, y
end

local function MAP_clear()
	--dprint("MAP CLEAR...")
	for i = 1, (MAP_WIDTH*MAP_HEIGHT)
		map[i] = 0
	end
	rooms = {}
	paths = {}
end

local function MAP_makepath(x, y, w, h)
	--dprint("GENERATING PATH...")
	if w and h
		dprint("ERROR: Path generation cannot use both width and height!")
		return
	end

	paths[#paths+1] = {
		x = x,
		y = y,
		w = w,
		h = h,
		l = 0
	}

	local start = MAP_coord2table(x,y)

	if w	-- horizontal paths
		for i = start, start+w
			map[i] = 1
		end
	else	-- vertical paths
		for i = 0, h or 0
			map[start+(i*MAP_WIDTH)] = 1
		end
	end
end

-- this actually generates a room of w+1 and h+1... br
local function MAP_makeroom(x, y, w, h, noadd)
	--dprint("GENERATING ROOM...")

	local r_start 	= MAP_coord2table(x, y)
	local r_end		= MAP_coord2table(x+w, y)

	if not noadd
		rooms[#rooms+1] = {
			x = x,
			y = y,
			w = w,
			h = h
		}
	end

	-- rooms are generated by drawing columns from top left to bottom right :)
	-- which is why we don't use y+h on r_end

	for i = r_start, r_end
		for j = 0, h
			map[i+(j*MAP_WIDTH)] = noadd and T_NOSWITCH or T_EMPTY
			if i+(j*MAP_WIDTH) > MAP_WIDTH*MAP_HEIGHT
				dprint("ERROR: Room generation continued out of range. (# > "..MAP_WIDTH*MAP_HEIGHT..")")
				break
			end
		end
	end
end

-- check if the entire area specified is clear
local function MAP_isclear(x, y, w, h)

	local r_start 	= MAP_coord2table(x, y)
	local r_end		= MAP_coord2table(x+w, y)

	if r_start < 0 or r_end < 0
		return false
	end	-- no use even checking, it's out of the god damn map

	for i = r_start, r_end
		for j = 0, h
			if i+(j*MAP_WIDTH) > MAP_WIDTH*MAP_HEIGHT
				return false
			end	-- out of the map

			if map[i+(j*MAP_WIDTH)] ~= 0	-- something exists
				return false
			end	-- youch
		end
	end

	return true	-- we're good
end

local function MAP_rooms(n)
	--dprint("MAP ROOMS...")
	rooms = {}	-- clear rooms

	local maxsize = max(2, 5 - (n/4))

	-- generate a random number of rooms.

	local nrooms = n or P_RandomRange(5, 8)
	for i = 1, nrooms

		/* 	As a general rule of thumb, we won't make any room too far down on the map to avoid
			them being cut off.	*/
		local x, y, w, h = P_RandomRange(4, 35), P_RandomRange(8, 32), P_RandomRange(2, maxsize), P_RandomRange(2, maxsize)
		local retry

		while not retry
			-- try not to make overlapping rooms, but leave the possibility

			local r_start 	= MAP_coord2table(x, y)
			local r_end		= MAP_coord2table(x+w, y)

			for i = r_start, r_end
				for j = 0, h
					if map[i+(j*MAP_WIDTH)]
						retry = true
						break
					end
				end
				if retry
					break
				end
			end
			if retry
				x, y, w, h = P_RandomRange(4, 35), P_RandomRange(8, 32), P_RandomRange(2, maxsize), P_RandomRange(2, maxsize)
			end
			retry = true
		end

		MAP_makeroom(x, y, w, h)
	end
end


-- -d doesn't check if we pathed everything, used for randomization.
local function MAP_paths(d)
	--dprint("MAP PATHS...")


	if not #rooms
		dprint("ERROR: No rooms were found.")
		return
	end

	-- connect every room to the next room and back to the first. if "d" is specified, make 'd' random paths instead!

	local pathed = {}	-- keep track of rooms we already pathed
	local hadlongpath 	-- we must have at least 1 elongated path for the exit

	for f = 1, (d or #rooms)

		local start, finish

		if d	-- Pick a random start and finish
			start = P_RandomRange(1, #rooms)
			finish = P_RandomRange(1, #rooms)
		else
			start = f
			if f == #rooms
				finish = 1
			else
				finish = f+1
			end
		end

		-- pick a random room to start from:
		local startroom = rooms[start]	-- awesome
		-- pick another room we will connect it to:
		local targetroom
		if not d
			targetroom = rooms[finish]
			--print(targetroom)
		else
			while (not targetroom) or (pathed[finish])	-- keep trying until targetroom is unpathed and exists.
				finish = P_RandomRange(1, #rooms)
				targetroom = rooms[finish]
				while targetroom == startroom	-- oh shit fuck.
					start = P_RandomRange(1, #rooms)
					startroom = rooms[start]	-- select another start room to avoid cases where a single room would path to itself.
				end
			end
		end	

		--dprint("PATHING ROOM "..start.." TO ROOM "..finish)

		-- we now have a start and a finish, let's proceed to make the path between those 2 rooms:
		/* To get to a new room, we will always follow this procedure:
			-Start at startroom center
			-Go to targetroom center X
			-Go to targetroom center Y	*/

		-- paths are limited and only go --->>>> or VVVVV

		local x_tcenter = clamp((targetroom.x*2+targetroom.w)/2 + P_RandomRange(-targetroom.w+1, targetroom.w-1), targetroom.x, targetroom.x + targetroom.x+targetroom.w)	-- room X centers
		local x_scenter = clamp((startroom.x*2+startroom.w)/2 + P_RandomRange(-startroom.w+1, startroom.w-1), startroom.x, startroom.x + startroom.x+startroom.w)

		local y_tcenter = clamp((targetroom.y*2+targetroom.h)/2 + P_RandomRange(-targetroom.h+1, targetroom.h-1), targetroom.y, targetroom.y+targetroom.h)	-- room Y centers
		local y_scenter = clamp((startroom.y*2+startroom.h)/2 + P_RandomRange(-startroom.h+1, startroom.h-1), startroom.y, startroom.y+startroom.h)

		local path_end = {}	-- coordinates at which our first path ended

		local rnd_more = 0	-- make path longer to create dead ends
		if P_RandomRange(0, 4) == 0 or (j == #rooms and not hadlongpath)	-- generate dead end for exit if we made it without a single one of em
			rnd_more = P_RandomRange(3, 8)
			hadlongpath = true
		end

		-- 1: align X axis:
		if x_scenter < x_tcenter
			MAP_makepath(x_scenter, y_scenter, x_tcenter-x_scenter +rnd_more)
			path_end = {x_scenter+(x_tcenter-x_scenter), y_scenter}
		else
			-- xscenter > xtcenter
			MAP_makepath(x_tcenter, y_scenter, x_scenter-x_tcenter +rnd_more)
			path_end = {x_tcenter+(x_scenter-x_tcenter), y_scenter}
		end

		if rnd_more	-- set path field to long:
			paths[#paths].l = true
		end


		rnd_more = 0	-- make path longer to create dead ends
		if P_RandomRange(0, 4) == 0
			rnd_more = P_RandomRange(3, 8)
			hadlongpath = true
		end

		--2: align Y axis:
		if y_scenter < y_tcenter
			MAP_makepath(x_tcenter, y_scenter, nil, y_tcenter-y_scenter +rnd_more)
		else	-- y_scenter > y_tcenter
			MAP_makepath(x_tcenter, y_tcenter, nil, y_scenter-y_tcenter +rnd_more)
		end

		if rnd_more	-- set path field to long:
			paths[#paths].l = true
		end

		--dprint("PATHED ROOM")
		if not d	-- nopathcheck
			pathed[finish] = true	-- targetroom has been pathed!
		end
		-- although the path also connects to startroom, we won't consider it pathed in case the map starts splitting in half or whatever the fuck it tries doing.
	end
	--dprint("PATHED ALL ROOMS (TOTAL "..#rooms..")")

end

local function MAP_items()
	--dprint("MAP ITEMS...")

	local strongfact = 1
	if server.gentype == GEN_STRONG
	or server.gentype == GEN_DREAD
		strongfact = 2
	end

	-- count parties...
	local parties = 1
	if server.plentities
		for i = 1, 4
			if server.plentities[i]
			and server.plentities[i][1]
			and server.plentities[i][1].valid
				parties = i
			end
		end
	end

	--debug:
	--parties = 3

	local spawneditems = {}

	-- generate items in rooms
	for k,v in ipairs(rooms) do
		if P_RandomRange(0, 4) < 2*strongfact
			local x, y = v.x + P_RandomRange(0, 1)*v.w, v.y+P_RandomRange(0, 1)*v.h	-- try to generate on borders
			local coord = MAP_coord2table(x, y)
			map[coord] = T_ITEM
			spawneditems[#spawneditems+1] = coord
		end
	end

	-- generate items in dead ends, sometimes.
	for k,v in ipairs(paths) do
		if not v.l continue end
		if P_RandomRange(0, 4) < 1*strongfact
			local x, y
			if v.w
				x, y = v.x + v.w, v.y
			else
				x, y = v.x, v.y + v.h
			end
			local coord = MAP_coord2table(x, y)
			map[coord] = T_ITEM
			spawneditems[#spawneditems+1] = coord
		end
	end

	if parties > 1

		local sgoldbox = 0
		local numgoldbox = min(#spawneditems/2, max(1, parties/2 +1))

		while sgoldbox < numgoldbox
		and #spawneditems
			local rnd = P_RandomRange(1, #spawneditems)
			map[spawneditems[rnd]] = T_GOLDI
			table.remove(spawneditems, rnd)
			sgoldbox = $+1
			--print("Gold box: "..sgoldbox.."/"..numgoldbox)
		end
	end
end

local function MAP_enemies()
	--dprint("MAP ENEMIES...")

	if server.gentype == GEN_DREAD
		return
	end			-- no enemies on dread floors

	-- count parties...
	local parties = 1
	if server.plentities
		for i = 1, 4
			if server.plentities[i]
			and server.plentities[i][1]
			and server.plentities[i][1].valid
				parties = i
			end
		end
	end

	-- generate enemies in rooms
	local max_enemies = #rooms+2 + (parties-1)*2
	local spawned_enemies = 0

	-- spawn AT LEAST 3/4 of the enemies we want.
	while spawned_enemies < max_enemies*3/4

		-- generate enemies in dead ends, sometimes.

		for k,v in ipairs(paths) do
			if spawned_enemies >= max_enemies break end
			if not v.l continue end
			if P_RandomRange(0, 8) < 4
				local x, y
				if v.w
					x, y = v.x + v.w-1, v.y
				else
					x, y = v.x, v.y + v.h-1
				end
				map[MAP_coord2table(x, y)] = T_ENEMY
				spawned_enemies = $+1
			end
		end

		-- but we'd rater have them in rooms
		for k,v in ipairs(rooms) do
			if spawned_enemies >= max_enemies break end
			if P_RandomRange(0, 8) < 5
				local x, y = v.x + P_RandomRange(0, v.w), v.y+P_RandomRange(0, v.h)
				map[MAP_coord2table(x, y)] = 3	-- yep, enemies may in fact overlap items!
				spawned_enemies = $+1
			end
		end
	end
end

local function MAP_spawn()
	--dprint("Generating spawns")
	-- spawn can be... LITERALLY any block, we don't care.
	local numspawns = 0
	while numspawns < 4
		local s = P_RandomRange(1, MAP_WIDTH*MAP_HEIGHT)
		if map[s] == 1 or map[s] == 8	-- don't care
			map[s] = T_START
			numspawns = $+1
		end
	end
end

local deadend_exit

local function MAP_exit()
	-- exits always spawns in dead ends, overwriting the possible item there was there
	--dprint("Generating spring...")
	local didexit
	deadend_exit = nil

	for k,v in ipairs(paths) do
		if didexit return end
		if not v.l continue end
		local x, y
		if v.w
			x, y = v.x + v.w, v.y
			-- check surroundings:
			if map[MAP_coord2table(x, y+1)]
			or map[MAP_coord2table(x, y-1)]
			or (map[MAP_coord2table(x+1, y)] and map[MAP_coord2table(x-1, y)])
				continue	-- this is in the middle of a room or a corridor, what the fuck?
			end

		else
			x, y = v.x, v.y + v.h
			-- check surroundings:
			if map[MAP_coord2table(x+1, y)]
			or map[MAP_coord2table(x-1, y)]
			or (map[MAP_coord2table(x, y+1)] and map[MAP_coord2table(x, y-1)])
				continue	-- this is in the middle of a room or a corridor, what the fuck?
			end
		end

		map[MAP_coord2table(x, y)] = T_EXIT
		deadend_exit = MAP_coord2table(x, y)
		didexit = true
	end

	if didexit return end
	-- we couldn't have any dead end with suitable parameters...
	local x, y = rooms[1].x + P_RandomRange(0, rooms[1].w), rooms[1].y+P_RandomRange(0, rooms[1].h)
	map[MAP_coord2table(x, y)] = T_EXIT
	-- just do it somewhere random!
end

-- % chance of a tile being a pit:
local diff_pitchance = {
	1,	-- beginner: 1%
	2,	-- easy:	2%
	4,	-- normal:	4%
	6,	-- hard: 6%
	7,	-- spicy: 7%
	7,	-- master: 7%
	8,	-- masochist: 8%
}	-- yes these difficulty names aren't even consistent.

local function MAP_pits()

	local pitfact = 1
	if server.gentype == GEN_PERFORATED
		pitfact = 3
	end
	
	local difficulty = server.difficulty or 1
	if server.cdungeon
		difficulty = server.cdungeon.gensize
	end
	
	local success = 0

	while success < 3
		for i = 1, 2048
			if map[i] == 1
			and P_RandomRange(0, 100) <= (diff_pitchance[difficulty] or 2)*pitfact
				map[i] = T_PIT

				if server.P_DungeonStatus.floor >= FRACUNIT
					map[i] = T_SPIKES
				end	-- use spike pits for monad
				success = $+1
			end
		end
	end	
end

local diff_spikechance = {
	1,
	1,
	2,
	2,
	2,
	3,
	3,
}

local function MAP_spikes()

	local difficulty = server.difficulty or 1
	if server.cdungeon
		difficulty = server.cdungeon.gensize
	end

	for i = 1, 2048
		if map[i] == 1
		and P_RandomRange(0, 100) <= (diff_spikechance[difficulty])

			map[i] = T_FLOORSPIKES	-- GUARANTEED

			-- generate these spikes:
			local start = i-1 - MAP_WIDTH

			for j = 1, 9

				if map[start]
				and P_RandomRange(0, 100) <= 30
					map[start] = T_FLOORSPIKES
				end

				start = $+1
				if j%3 == 0
					start = $-4
					start = $+MAP_WIDTH
				end

			end

		end
	end

end

-- % chance of a tile being a ring cluster
local diff_ringchance = {
	4,	-- beginner: 4%
	3,	-- easy: 3%
	2,	-- normal: 2%
	2,	-- hard: 2%
	1,	-- spicy: 1%
	1,	-- master: 1%
	0,	-- madness: 0%
}

local function MAP_rings()

	local difficulty = server.difficulty or 1
	if server.cdungeon
		difficulty = server.cdungeon.gensize
	end

	local goldfact = 1
	if server.gentype == GEN_GOLD
		goldfact = 3
	end
	for i = 1, 2048
		if map[i] == 1
		and P_RandomRange(0, 100) <= (diff_ringchance[difficulty] or 2)*goldfact
			map[i] = 9
		end
	end
end

local numgateslookup = {0,0,0,0,1,1,1,1,2,2,2,3,3}

local function MAP_gates()
	local numgates = numgateslookup[P_RandomRange(1, #numgateslookup)]
	local pnum = 1

	local springgate
	for i = 1, numgates do

		-- Find where to generate the gate

		-- rarely, forcefully generate the gate right in front of the exit!
		if deadend_exit
		and not springgate	-- already got one!!
		and not P_RandomRange(0, 9)	-- 10%
			dprint("Found dead-end exit, generating gate #"..i)

			local free
			-- look for 4 cardinal directions next to the deadend

			local tries = {deadend_exit-1, deadend_exit+1, deadend_exit-(MAP_WIDTH*1), deadend_exit+(MAP_WIDTH*1)}
			-- left, right, down, up

			for i = 1, #tries do
				if map[tries[i]]	-- whatever if it replaces an enemy or something else
					free = tries[i]
					break	-- No use continuing
				end
			end

			if free
				dprint("Found free spot for gate #"..i)
				
				map[free] = T_GATE
				springgate = true
				continue	-- don't generate a normal gate
				-- reminder that the switch is set during map generation
			end
		end

		-- generate a normal gate in a path, why not!

		while pnum <= #paths

			local p = paths[pnum]
			dprint("Attempt to generate normal switch-room")

			local x, y = p.x, p.y

			local dir = p.w	-- width
			local tile = MAP_coord2table(x, y)
			local iter = 0

			if dir	-- left/right
				-- scout for areas up/down by checking tiles 1 by 1
				local generated
				while iter < p.w
				and not generated

					-- 1: check up:
					local x = p.x + iter
					local y = p.y

					if MAP_isclear(x-2, y-5, 4, 4)	-- check for a free 4x4 space from where we started!
					and map[MAP_coord2table(x, y)] ~= T_EXIT	-- don't generate a gate next to an exit!!

						generated = true
						dprint("TOP is clear, generate something!")

						map[MAP_coord2table(x, y-1)] = T_GATE	-- entrance
						MAP_makeroom(x-1, y-4, 2, 2, true)	-- make a room but don't add it to the rooms list...

						map[MAP_coord2table(x, y-3)] = T_ITEM	-- put a funky item :)

					elseif MAP_isclear(x-2, y+1, 4, 4)	-- check for a free 4x4 space from where we started!
					and map[MAP_coord2table(x, y)] ~= T_EXIT	-- don't generate a gate next to an exit!!

						generated = true
						dprint("BOTTOM is clear, generate something!")

						map[MAP_coord2table(x, y+1)] = T_GATE	-- entrance
						MAP_makeroom(x-1, y+2, 2, 2, true)	-- make a room but don't add it to the rooms list...

						map[MAP_coord2table(x, y+3)] = T_ITEM	-- put a funky item :)
					end

					if generated
						break 2	-- generate the next switch!
					end

					iter = $+1	-- keep trying...
				end
			end

			dprint("Failed, go to next path")
			pnum = $+1
		end
	end
end

-- base # of rooms per difficulty
local diff_rooms = {
	{4, 5},	-- beginner, 4 to 5 rooms
	{4, 6},	-- easy, 4 to 6 rooms
	{5, 6},	-- normal, 5 to 7 rooms
	{5, 7},	-- hard, 5 to 8 rooms
	{5, 8},	-- spicy, 6 to 9 rooms
	{5, 9}, -- master, 7 to 10 rooms
	{6, 10},
}

-- extra paths
local diff_paths = {
	{1, 2},	-- beginner, 1 to 2 extra paths
	{1, 3},	-- easy, 1 to 3 extra paths
	{2, 5},	-- normal, 2 to 5 extra paths
	{3, 6},	-- hard, 3 to 6 extra paths
	{4, 6},	-- spicy, 4 to 6 extra paths
	{2, 8},	-- master, 2 to 8 extra paths
	{3, 5},
}

rawset(_G, "MAP_generate", function(t)
	-- difficulty sets how many rooms etc we should be making
	local difficulty = server.difficulty or 1
	if server.cdungeon
		difficulty = server.cdungeon.gensize
	end	
	local d = difficulty

	-- special cases for some generation types:
	if d > 1
		-- these lower difficulty
		if t == GEN_DARK
			d = $-1
		end
	end

	local room_t, path_t

	for i = 1, #diff_rooms
		if diff_rooms[i] and i <= d
			room_t = diff_rooms[i]
		end
	end

	for i = 1, #diff_paths
		if diff_paths[i] and i <= d
			path_t = diff_paths[i]
		end
	end

	local numrooms = P_RandomRange(room_t[1], room_t[2])
	local numpaths = P_RandomRange(path_t[1], path_t[2])

	MAP_clear()			-- empty map
	MAP_rooms(numrooms)	-- generate rooms
	MAP_paths()			-- generate paths between rooms
	MAP_paths(numpaths)	-- path again but without worrying about which rooms we connect
	MAP_enemies()		-- generate enemies
	MAP_pits()			-- generate some pits
	MAP_spikes()		-- generate floor spikes
	MAP_rings()			-- generate ring clusters
	MAP_items()			-- generate items in rooms and sometimes in dead ends
	MAP_spawn()			-- generate spawn
	MAP_exit()			-- generate the exit
	MAP_gates()			-- Funny gates to block some goodies... or even the spring!
	dprint("Map generation complete!")
	return map
end)